---
title: "00-01. Identify qSVs using transcript counts and qsvaR"
author: "Rachel Smith"
format: html
editor: visual
---

Run qSVA using qsvaR to account for transcript degradation in post-mortem gene expression data.

Then combine with known covariates for covariate selection.

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
base_dir <- "~/Documents/PhD/projects/sgacc_wgcna_grcca/"
objects_dir <- paste0(base_dir, "outputs/objects/")
supp_figures_dir <- paste0(project_dir, "outputs/figures/supplement/")
```

## Libraries

```{r libraries, message=FALSE, warning=FALSE}
library(tidyverse)
library(janitor)
library(qsvaR)
library(biomaRt)
library(RColorBrewer)
library(pals)
library(patchwork)
library(DESeq2)
library(cowplot)
```

## Load data

```{r load_data}
# Transcript count data
df_transcript_raw_counts <- read.csv(paste0(base_dir, "data/transcript_count_matrix.csv")) %>% 
    as_tibble() %>% 
    dplyr::rename("ensembl_transcript_id" = "X") %>% 
    rename_all(~str_remove(.x, "_MergedBam_stringtieOutput")) %>% 
    clean_names() %>% 
    rename_all(~str_remove(.x, "x")) 

# Formatted covariate data
load(paste0(objects_dir, "22Jan2025_covariates.Rdata")) # df_covariates, df_covariates_clean (generated in 00_clean-covariates.R)

# Convert to matrix
m_metadata <- df_covariates_numeric %>% 
    as.data.frame %>% 
    column_to_rownames("sample") %>% 
    as.matrix

# Filter count data for samples that are included in covariate data
df_transcript_raw_counts <- df_transcript_raw_counts %>% 
    dplyr::select(ensembl_transcript_id, contains(df_covariates_numeric$sample))
```

## Remove low count transcripts

At least 10 raw counts in at least 80% of samples

```{r filter_counts}
keep <- df_transcript_raw_counts %>% 
    mutate_if(is.numeric, ~ifelse(.x >= 10, 1, 0)) %>% 
    mutate(thresh = rowSums(dplyr::select(., -ensembl_transcript_id))/(ncol(.) - 1), 
           .before = 2) %>% 
    filter(thresh >= 0.80) %>% 
    pull(ensembl_transcript_id)
length(keep) # 72403
  
## Filter df_transcripts for transcripts that meet filtering criteria
df_transcript_raw_counts_filtered <- df_transcript_raw_counts %>% 
    filter(ensembl_transcript_id %in% keep)
```

## Normalize transcript counts using VST from DESEq2

```{r normalize}
m_counts <- df_transcript_raw_counts_filtered %>% 
    as.data.frame %>% 
    column_to_rownames("ensembl_transcript_id") %>% 
    as.matrix + 1 # add a pseudo-count of 1 to avoid zeros in count mat

m_vsd <- varianceStabilizingTransformation(m_counts, blind = TRUE, fitType = "parametric")
```

## Map transcripts to degradation transcripts using version id from biomart

```{r map_transcripts}
# Use biomart to get transcript info 
ensembl <- useEnsembl(biomart = "genes", 
                      dataset = "hsapiens_gene_ensembl")

df_bm <- getBM(attributes = c("ensembl_transcript_id", 
                              "ensembl_transcript_id_version", "external_transcript_name", 
                              "ensembl_gene_id", "external_gene_name", 
                              "chromosome_name", "strand", 
                              "transcript_start", "transcript_end", "transcript_length", 
                              "transcript_biotype", "percentage_gene_gc_content"),
               filters = "ensembl_transcript_id",
               values = rownames(m_vsd),
               mart = ensembl) %>% 
    as_tibble()
  
## Get degradation transcripts from qsvaR
degradation_transcripts <- qsvaR::select_transcripts(cell_component = TRUE)
#df_bm %>% filter(ensembl_transcript_id_version %in% degradation_transcripts) # n = 1325

## Map transcript ID version to transcript in normalized count matrix
m_vsd_filt <- m_vsd %>% 
    
    # convert to tibble
    as.data.frame %>% 
    rownames_to_column("ensembl_transcript_id") %>% 
    as_tibble %>% 
    
    # join with biomart info
    left_join(df_bm[1:2], by = join_by(ensembl_transcript_id)) %>% 
    dplyr::select(ensembl_transcript_id_version, everything(), -ensembl_transcript_id) %>% 
    na.omit %>% 
    
    # include only samples that are in the metadata (exclude outliers)
    dplyr::select(ensembl_transcript_id_version, all_of(rownames(m_metadata))) %>% 
    
    # convert back to matrix
    as.data.frame %>% 
    column_to_rownames("ensembl_transcript_id_version") %>% 
    as.matrix
```

## Create RSE object

```{r create_rse}
## Row ranges object
gr <- GRanges(
    
    seqnames = Rle(df_bm$chromosome_name),
    ranges = IRanges(start = df_bm$transcript_start,
                     end = df_bm$transcript_end,
                     #width = df_bm$transcript_length,
                     names = rownames(m_vsd_filt)),
    strand = Rle(strand(df_bm$strand)),
    
    transcript_name = df_bm$external_transcript_name,
    type = df_bm$transcript_biotype,
    ensembl_gene_id = df_bm$ensembl_gene_id,
    gene_name = df_bm$external_gene_name,
    GC = df_bm$percentage_gene_gc_content
    
)

## Create RSE (for qSVA input)
rse_tx <- SummarizedExperiment(assays = SimpleList(counts = m_vsd_filt),
                               rowRanges = gr,
                               colData = m_metadata)
```

## Run qSVA

```{r run_qsva}
## Identify degradation matrix for our transcripts
DegTx <- getDegTx(rse_tx,
                  sig_transcripts = degradation_transcripts,
                  assayname = "counts")

## Extract PCs from this matrix
set.seed(20240306)
pcTx <- getPCs(rse_tx = DegTx,
               assayname = "counts")

df_qsv_var_expl <- summary(pcTx)$importance %>% 
    as.data.frame() %>% 
    rownames_to_column("feature") %>% 
    as_tibble %>% 
    pivot_longer(2:ncol(.), names_to = "PC", values_to = "value") %>% 
    mutate(qSV = str_remove(PC, "PC") %>% as.numeric %>% factor(levels = c(1:max(.)))) 

## Design a basic model matrix to model the number of PCs (qSVs) needed
mod <- model.matrix(~ dx,
                    data = colData(rse_tx)
)

## Wrapper function to extract qSVs
set.seed(20240306)
qsvs <- qSVA(rse_tx = rse_tx, sig_transcripts = degradation_transcripts, 
             mod = mod, assayname = "counts")

## Convert to tibble
df_qsvs <- qsvs %>% 
    as.data.frame %>% 
    rownames_to_column("sample") %>% 
    as_tibble()
```

## Correlate qSVs with known covariates

```{r correlate_qsva}
## Identify covariates and qSVs to correlate
covariates <- df_covariates_numeric %>% dplyr::select(-sample) %>% colnames
qsvs <- df_qsvs %>% dplyr::select(-sample) %>% colnames
  
## Run all pairwise combinations of correlations  
df_covariate_qsv_cor <- expand_grid(
    covariate = covariates,
    qsv = qsvs
) %>% 
    mutate(
        pearsons_r = map2(
            .x = covariate,
            .y = qsv,
            .f = ~ cor.test(df_covariates_numeric[[.x]], df_qsvs[[.y]])$estimate
        ),
        p_value = map2(
            .x = covariate,
            .y = qsv,
            .f = ~ cor.test(df_covariates_numeric[[.x]], df_qsvs[[.y]])$p.value
        )
    ) %>% 
    unnest(cols = c(pearsons_r, p_value)) %>% 
    mutate(p_adj = p.adjust(p_value, method = "fdr")) %>% 
    mutate(qsv = str_remove(qsv, "qSV") %>% 
               as.numeric %>% 
               as.factor)
```

## Save objects

```{r save}
save(df_qsvs, df_qsv_var_expl, df_covariate_qsv_cor,
     file = paste0(objects_dir, "06March2024_qSVs.Rdata")
) # df_qsvs, df_qsv_var_expl
```

## Plots

```{r set_plot_aesthetics}
theme_set(theme_cowplot() +
              theme(plot.title = element_text(size = 11),
                    axis.title = element_text(size = 10),
                    axis.text = element_text(size = 9),
                    strip.text = element_text(size = 10),
                    legend.title = element_text(size = 9),
                    legend.text = element_text(size = 8),
                    plot.margin = margin(t = 0, r = 5, l = 0, b = 0)
              )
)
```

### Figure S2A \| Variance explained by qSVs

```{r FigS2a.plot, fig.height = 2, fig.width = 2.5}
df_qsv_var_expl %>% #dplyr::count(feature)
    dplyr::filter(feature == "Proportion of Variance" & qSV %in% 1:16) %>%
    
    ggplot(aes(x = qSV, y = value*100)) +
    geom_col(aes(fill = value), color = "black") +
    geom_hline(yintercept = 0.02*100, color = "maroon") +
    scale_fill_gradient(low = "white", high = "black", 
                        limits = c(0, 0.06), guide = "none") +
    #scale_y_continuous(breaks = seq(0, 0.06, 0.01)) +
    coord_cartesian(clip = "off") +
    labs(y = "% variance explained",
         title = "A | qSV variance explained") +
    theme(axis.text.x = element_text(angle = 45))

# Save
map(
  .x = c(".png", ".pdf"),
  .f = ~ ggsave(paste0(supp_figures_dir, "S2A.qSV_variance_explained", .x), 
                width = 2.5, height = 2)
)
```

### Figure S2B \| Correlate qSVs with known covariates

```{r FigS2b.prep}
## Define covariate types
technical_covariates <- c(
    "mapped_percent", "gc_percent", "five_prime_three_prime_bias", 
    "rin_acsg", "rna_extraction_batch",
    "library_batch", "pmi", "pmi_confidence", "source", "ph", #"max_rin", "max_rine"
)
biological_covariates <- c(
    "age_death", "sex_at_birth", "race", "bmi", "height", "weight",
    "marital_status", "manner_death", "education", "suicide", "brain_weight"
)
drug_covariates <- c(
    "smoker", "nicotine_cotinine", "alcohol", "opioids", 
    "cannabinoids", # "beta_blockers", # remove beta blockers due to too many missing values
    "major_stimulants_cocaine_included", "minor_stimulants", 
    "anticholinergics", "antidepressants",
    "anti_epileptics", "anti_histamines", "antipsychotics", 
    "mood_stabilizers", "sedative_hypnotic_anxiolitics", "benzos",
    "other_psychotropic_drug", "non_psychiatric"
)

## Define covariate order based on clustering within each type
f_define_order <- function(covariate_matrix, 
                           covariate_type = c("technical", "biological", "toxicological")) {
    if (covariate_type == "technical") {
        subset <- technical_covariates
    } else if (covariate_type == "biological") {
        subset <- biological_covariates
    } else if (covariate_type == "toxicological") {
        subset <- drug_covariates
    } else (stop("Covariate type must be technical, biological, or toxicological"))
    matrix_tmp <- covariate_matrix[,subset]
   order <- matrix_tmp[hclust(dist(matrix_tmp))$order,] %>% colnames
   return(order)
}
m_covariates <- df_covariates_numeric %>% 
    dplyr::select(all_of(c(technical_covariates, biological_covariates, drug_covariates))) %>%  
    as.matrix()
covariate_order <- c(
    f_define_order(m_covariates, "biological"),
    f_define_order(m_covariates, "toxicological"),
    f_define_order(m_covariates, "technical")
)


## Switch major_stimulants_cocaine_included and cannabinoids for the plot
swtch <- function(vec, value1, value2) {
  # Ensure the values exist in the vector
  if (!(value1 %in% vec) || !(value2 %in% vec)) {
    stop("Both values must exist in the vector.")
  }
  
  # Find the positions of the values
  pos1 <- which(vec == value1)
  pos2 <- which(vec == value2)
  
  # Swap the elements
  vec[pos1] <- value2
  vec[pos2] <- value1
  
  return(vec)
}
covariate_order <- swtch(covariate_order, "major_stimulants_cocaine_included", "cannabinoids")

## Create dataframe defining covariate type & order
df_figS2b <- df_covariate_qsv_cor %>% 
    mutate(significance = case_when(
        p_adj < 0.05 & p_adj > 0.01 ~ "*",
        p_adj < 0.01 ~ "**",
        TRUE ~ ""
    ),
           type = case_when(
               covariate %in% technical_covariates ~ "Technical",
               covariate %in% biological_covariates ~ "Biological",
               covariate %in% drug_covariates ~ "Toxicological",
               TRUE ~ "Diagnostic group"
           ) %>% 
               factor(levels = 
                          c("Diagnostic group", "Technical", "Toxicological", "Biological"))
    ) %>% 
    filter(type != "Diagnostic group") %>% 
    arrange(type, qsv, pearsons_r) %>% 
    mutate(covariate = factor(covariate, levels = covariate_order))
```

```{r FigS2b.plot, fig.height = 6.5, fig.width = 4}
df_figS2b %>% 
    ggplot(aes(x = qsv, y = covariate)) +
    geom_tile(aes(fill = pearsons_r), width = 0.98, height = 0.98) +
    geom_text(aes(label = significance), vjust = 0.75) +
    facet_wrap(vars(type), scales = "free", space = "free_y", ncol = 1) +
    
    scale_fill_gradientn(colors = rev(brewer.rdbu(100))) +
    coord_cartesian(clip = "off") +
    guides(fill = guide_colorbar(title = "Pearson's r", 
                                 title.hjust = 0.5, title.position = "left")) +
    labs(x = "qSV", y = NULL, 
         title = "B | qSVs and known \ncovariate correlations"
    ) +
    theme(legend.position = c(-1.1, 1.0),
          legend.key.height = unit(0.6, "cm"),
          legend.key.width = unit(0.15, "cm"),
          legend.title = element_text(angle = 90),
          axis.text.x = element_text(angle = 45),
          strip.background = element_rect(fill = "white", color = "black")
    )

# Save
map(
  .x = c(".png", ".pdf"),
  .f = ~ ggsave(paste0(supp_figures_dir, "S2B.qSV_covariate_correlations", .x), 
                width = 4, height = 6.5)
)
```
