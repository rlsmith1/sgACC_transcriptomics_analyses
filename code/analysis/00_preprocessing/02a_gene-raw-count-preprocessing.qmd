---
title: "02a_gene-raw-count-preprocessing"
author: "Rachel Smith"
format: html
editor: visual
---

# GENES: Read in raw count data, normalize using DESeq2, qSVA correction & regress covariates

Identify covariates to regress from gene expression data and include as covariates in DGE model.

This is a stepwise script: regress --\> run PCA --\> check expression PC-covariate correlations --\> repeat.

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
base_dir <- "~/Documents/PhD/projects/sgacc_wgcna_grcca/"
figures_dir <- paste0(base_dir, "outputs/figures/supplement/")
analysis_objects_dir <- paste0(base_dir, "outputs/objects/")
```

## Libraries

```{r libraries, message=FALSE, warning=FALSE}
library(tidyverse)
library(DESeq2)
```

## Load data

```{r load_data}
# Cleaned covariates
load(paste0(base_dir, "objects/22Jan2025_covariates.Rdata")) # df_covariates, df_covariates_numeric (generated in 00_clean-covariates.R)

# Gene raw counts
df_raw_counts <- read.table(
    paste0(base_dir, 
           "data/185samples_allGenes_auto-PARs_noSexChrs_noFilters_KoryAnalysis_21Kgenes.txt")) %>% 
    as_tibble(rownames = "ensembl_gene_id") %>% 
    rename_at(2:ncol(.), ~substr(.x, start = 2, stop = nchar(.x))) %>% 
    clean_names() %>% 
    dplyr::rename_at(2:ncol(.), ~str_remove(.x, "x"))

# Filter for samples that are in covariate data
df_raw_counts <- df_raw_counts %>% 
  dplyr::select(ensembl_gene_id, contains(df_covariates_numeric$sample))

# Load QSVs (generated in 01_qSVA.R)
load(paste0(base_dir, "objects/06March2024_qSVs.Rdata")) # df_qsvs, df_qsv_var_expl, df_covariate_qsv_cor

# Combine qSVs with numeric covariate data
df_covar_qsv <- df_covariates_numeric %>% left_join(df_qsvs)

# Set order using hclust (for plots)
m_covariates <- df_covariates_numeric %>% column_to_rownames("sample") %>% t()
covariate_order <- m_covariates[hclust(dist(m_covariates))$order,] %>% rownames
```

## Remove low count genes

At least 10 raw counts in at least 80% of samples

```{r filter_counts}
keep <- df_raw_counts %>% 
  mutate_if(is.numeric, ~ifelse(.x >= 10, 1, 0)) %>% 
  mutate(thresh = rowSums(dplyr::select(., -ensembl_gene_id))/(ncol(.) - 1), .before = 2) %>% 
  dplyr::filter(thresh >= 0.80) %>% 
  pull(ensembl_gene_id)
length(keep) # n = 18677

# filter df_transcripts for genes that meet this threshold
df_raw_counts_filtered <- df_raw_counts %>% 
  dplyr::filter(ensembl_gene_id %in% keep)
```

## STEP 1: Normalize counts using VST

```{r normalize}
m_counts <- df_raw_counts_filtered %>% 
  as.data.frame %>% 
  column_to_rownames("ensembl_gene_id") %>% 
  as.matrix + 1 # add a pseudo-count of 1 to avoid zeros in count mat

m_vsd <- varianceStabilizingTransformation(m_counts, blind = TRUE, fitType = "parametric")
```

## PCA1: on normalized counts with no regression

```{r pca1}
## PCA on normalized counts
pca1 <- prcomp(m_vsd,
               center = TRUE, scale = TRUE)

df_pca1 <- pca1$rotation %>% 
  as.data.frame %>% 
  rownames_to_column("sample") %>% 
  as_tibble() %>% 
  left_join(df_covar_qsv) %>% 
  clean_names()

df_var1 <- summary(pca1) %>% 
  .$importance %>% 
  as.data.frame %>% 
  rownames_to_column("metric") %>% 
  as_tibble() %>% 
  pivot_longer(2:ncol(.), values_to = "value", names_to = "PC") %>% 
  mutate(PC = str_remove(PC, "PC") %>% as.numeric()) %>% 
  pivot_wider(id_cols = PC, names_from = metric, values_from = value) %>% 
  clean_names()

## Correlate PCs with covariates
df_pca1_covar_cor <- df_pca1 %>% 
    pivot_longer(contains("pc"), names_to = "pc", values_to = "pc_val") %>% 
    pivot_longer(!contains(c("pc", "sample")), 
                 names_to = "covariate", 
                 values_to = "covariate_val") %>% 
    group_by(pc, covariate) %>% 
    nest() %>% 
    
    # correlate all pairwise combinations of PCs and covariates
    mutate(pearsons_r = map(.x = data, .f = ~ cor.test(.x$pc_val, .x$covariate_val)$estimate),
           p_val = map(.x = data, .f = ~ cor.test(.x$pc_val, .x$covariate_val)$p.value)) %>% 
    unnest(cols = c(pearsons_r, p_val)) %>% 
    ungroup %>% 
    mutate(p_adj = p.adjust(p_val, method = "fdr")) %>% 
    
    # format df aesthetics
    mutate(covariate = str_replace(covariate, "q_sv", "qSV"),
           covariate = factor(covariate, levels = c(covariate_order, paste0("qSV", 1:16))),
           pc = str_remove(pc, "pc")) %>% 
    left_join(df_var1 %>% mutate(pc = as.character(pc))) %>% 
    dplyr::filter(proportion_of_variance > 0.02) %>% 
    mutate(significant = ifelse(p_adj < 0.05, "yes", "no"))


## Plot PCA1
p_pca <- df_pca1 %>% 
  ggplot(aes(x = pc1, y = pc2)) +
  geom_point(aes(fill = q_sv1), shape = 21, size = 2) +
  scale_fill_gradientn(colors = brewer.pal(9, "YlOrRd")) +
  guides(fill = guide_colorbar(title = "qSV1")) +
  
  # add origin lines
  # geom_vline(xintercept = 0, color = "black", lty = 2) +
  # geom_hline(yintercept = 0, color = "black", lty = 2) +
  
  # give % variance in axis labels
  xlab(paste0("PC1: ", 
              df_var1 %>% filter(pc == 1) %>% pull(proportion_of_variance) *100 %>% round(2),
              "% of variance")) +
  ylab(paste0("PC2: ", 
              df_var1 %>% filter(pc == 2) %>% pull(proportion_of_variance) *100 %>% round(2),
              "% of variance")) +
  theme(legend.position = c(0.90, 0.80))


## Plot eigenvalues
p_var <- df_var1 %>% 
  ggplot(aes(x = pc, y = proportion_of_variance)) +
  geom_bar(aes(fill = proportion_of_variance), stat = "identity",
           color = "black", linewidth = 0.05) +
  geom_hline(aes(yintercept = 0.02), lty = 2, color = "red") +
  scale_fill_gradient(low = "white", high = "midnightblue", 
                      limits = c(0, 1.0), guide = "none") +
  labs(x = "PC", y = "Proportion of variance explained")

p_pca + p_var + plot_annotation(title = "PCA 1: VST normalized counts before qSV regression")

# SAVE
# map(
#   .x = c(".png", ".pdf"),
#   .f = ~ ggsave(paste0(figures_dir, "PCA1_GENES_normalized_counts", .x),
#                 width = 10, height = 5)
# )
```

## STEP 2: regress qSVs qSV1-7 + 9 from gene level

Start by regression only qSVs that meeting significance criteria (\>2% variance explained or correlate with known covariates). Also regress sex & race up front becuase we don't want these demographic variables influencing modules.

```{r regress_step2}
df_qsvs %>% dplyr::select(-sample) %>% colnames
keep_qsvs <- paste0("qSV", c(seq(1, 7), 9)) # correlate with known covariates or var explained > 2%
mod <- df_covar_qsv %>% 
  dplyr::select(all_of(keep_qsvs), sex_at_birth, race) %>% 
  as.data.frame %>% 
  as.matrix

## Regress from count data
doParallel::registerDoParallel()
df_vsd_regress <- tibble(sample = colnames(m_vsd))  
for (i in 1:nrow(m_vsd)) {
  
  if (i %% 100 == 0) {print(paste0(i, " of ", nrow(m_vsd)))}
  
  gene <- rownames(m_vsd)[i]
  df <- cbind(m_vsd = m_vsd[i,], mod) %>% as.data.frame()
  m_vsd_clean <- (lm(m_vsd ~ ., data = df) %>% residuals) #+ mean(df$m_vsd) # add mean for interpretable expression value
  
  df_vsd_regress[[gene]] <- m_vsd_clean
  
}  
```

## PCA2: vsd \~ qSV1-7 + 9 + sex_at_birth + race

```{r pca2}
## PCA on normalized and regressed counts   
pca2 <- prcomp(df_vsd_regress %>%
                 column_to_rownames("sample") %>% 
                 t(),
               center = TRUE, scale = TRUE)

df_pca <- pca2$rotation %>% 
  as.data.frame %>% 
  rownames_to_column("sample") %>% 
  as_tibble() %>% 
  left_join(df_covar_qsv) %>% 
  clean_names()

df_var <- summary(pca2) %>% 
  .$importance %>% 
  as.data.frame %>% 
  rownames_to_column("metric") %>% 
  as_tibble() %>% 
  pivot_longer(2:ncol(.), values_to = "value", names_to = "PC") %>% 
  mutate(PC = str_remove(PC, "PC") %>% as.numeric()) %>% 
  pivot_wider(id_cols = PC, names_from = metric, values_from = value) %>% 
  clean_names()


## Plot PCA2
p_pca <- df_pca %>% 
  ggplot(aes(x = pc1, y = pc2)) +
  geom_point(aes(fill = q_sv1), shape = 21, size = 2) +
  scale_fill_gradientn(colors = brewer.pal(9, "YlOrRd")) +
  guides(fill = guide_colorbar(title = "qSV1")) +
  
  # add origin lines
  # geom_vline(xintercept = 0, color = "black", lty = 2) +
  # geom_hline(yintercept = 0, color = "black", lty = 2) +
  
  # give % variance in axis labels
  xlab(paste0("PC1: ", 
              df_var %>% filter(pc == 1) %>% pull(proportion_of_variance) *100 %>% round(2),
              "% of variance")) +
  ylab(paste0("PC2: ", 
              df_var %>% filter(pc == 2) %>% pull(proportion_of_variance) *100 %>% round(2),
              "% of variance")) +
  theme(legend.position = c(0.10, 0.25))


## Plot eigenvalues
p_var <- df_var %>% 
  ggplot(aes(x = pc, y = proportion_of_variance)) +
  geom_bar(aes(fill = proportion_of_variance), stat = "identity",
           color = "black", linewidth = 0.05) +
  geom_hline(aes(yintercept = 0.02), lty = 2, color = "red") +
  scale_fill_gradient(low = "white", high = "midnightblue", 
                      limits = c(0, 0.07), guide = "none") +
  labs(x = "PC", y = "Proportion of variance explained")

p_pca / p_var + 
    plot_annotation(title = "PCA 2: VST normalized counts with qSV + sex at birth + race regression")


## Save
# map(
#   .x = c(".png", ".pdf"),
#   .f = ~ ggsave(paste0(base_dir, "outputs/figures/for_manuscript/qSVA/PCA2_GENES_normalized_and_regressed_counts", .x),
#                 width = 6, height = 8)
# )


## Correlate PCs with covariates
df_pc_covar_cor <- df_pca %>% 
  pivot_longer(contains("pc"), names_to = "pc", values_to = "pc_val") %>% 
  pivot_longer(!contains(c("pc", "sample")), names_to = "covariate", values_to = "covariate_val") %>% 
  group_by(pc, covariate) %>% 
  nest() %>% 
  mutate(pearsons_r = map(.x = data, .f = ~ cor.test(.x$pc_val, .x$covariate_val)$estimate),
         p_val = map(.x = data, .f = ~ cor.test(.x$pc_val, .x$covariate_val)$p.value)) %>% 
  unnest(cols = c(pearsons_r, p_val)) %>% 
  ungroup %>% 
  mutate(p_adj = p.adjust(p_val, method = "fdr"))


## Plot covariate-PC correlations   
df_pc_covar_cor %>% 
  mutate(covariate = str_replace(covariate, "q_sv", "qSV"),
         covariate = factor(covariate, levels = c(covariate_order, paste0("qSV", 1:16))),
         pc = str_remove(pc, "pc") %>% as.numeric) %>% 
  left_join(df_var) %>% 
  filter(proportion_of_variance > 0.02) %>% 
  mutate(significant = ifelse(p_adj < 0.05, "yes", "no")) %>% 
  
  ggplot(aes(x = pc, y = covariate)) +
  geom_tile(aes(fill = pearsons_r, color = significant), 
            width = 0.98, height = 0.98, linewidth = 0.5) +
  scale_fill_gradient2(low = "blue", mid = "white", high = "red") +
  scale_color_manual(values = c("yes" = "black", "no" = "transparent"), guide = "none") +
  guides(fill = guide_colorbar(title = "Pearson's r")) +
  labs(x = "PC (> 2% explained var)", title = "PC-covariate correlations following qSV regression",
       caption = "Box outline indicates FDR < 0.05") +
  theme_classic() +
  theme(legend.key.height = unit(2, "cm"))


## Save
# map(
#   .x = c(".png", ".pdf"),
#   .f = ~ ggsave(paste0(base_dir, "outputs/figures/for_manuscript/qSVA/PCA2_GENES_covariate_correlations", .x),
#                 width = 8, height = 8)
# )
```

## STEP 3: regress technical covariates that still significantly correlate with significant PCs

Regress same covariates as before, but this time also regress age at death and GC percent because these variables still correlated with expression PCs.

```{r regress_step3}
df_qsvs %>% dplyr::select(-sample) %>% colnames
keep_qsvs <- paste0("qSV", c(seq(1, 7), 9)) # correlate with known covariates or var explained > 2%
mod <- df_covar_qsv %>% 
  dplyr::select(all_of(keep_qsvs), sex_at_birth, race, age_death, gc_percent) %>% 
  as.data.frame %>% 
  as.matrix


## Run regression 
doParallel::registerDoParallel()
df_vsd_regress <- tibble(sample = colnames(m_vsd))  
for (i in 1:nrow(m_vsd)) {
  
  if (i %% 100 == 0) {print(paste0(i, " of ", nrow(m_vsd)))}
  
  gene <- rownames(m_vsd)[i]
  df <- cbind(m_vsd = m_vsd[i,], mod) %>% as.data.frame()
  m_vsd_clean <- (lm(m_vsd ~ ., data = df) %>% residuals) #+ mean(df$m_vsd) # add mean for interpretable expression value
  
  df_vsd_regress[[gene]] <- m_vsd_clean
  
}  

df_vsd_regress
```

## PCA3: vsd \~ qSV1-7 + 9 + sex_at_birth + race + age_death + gc_percent

```{r pca3}
## Run PCA on normalized & regressed counts (qSVs + known covariates)
pca3 <- prcomp(df_vsd_regress %>%
                 column_to_rownames("sample") %>% 
                 t(),
               center = TRUE, scale = TRUE)

df_pca3 <- pca3$rotation %>% 
  as.data.frame %>% 
  rownames_to_column("sample") %>% 
  as_tibble() %>% 
  left_join(df_covar_qsv) %>% 
  clean_names()

df_var3 <- summary(pca3) %>% 
  .$importance %>% 
  as.data.frame %>% 
  rownames_to_column("metric") %>% 
  as_tibble() %>% 
  pivot_longer(2:ncol(.), values_to = "value", names_to = "PC") %>% 
  mutate(PC = str_remove(PC, "PC") %>% as.numeric()) %>% 
  pivot_wider(id_cols = PC, names_from = metric, values_from = value) %>% 
  clean_names()


## Correlate PCs with covariates
df_pca3_covar_cor <- df_pca3 %>% 
    pivot_longer(contains("pc"), names_to = "pc", values_to = "pc_val") %>% 
    pivot_longer(!contains(c("pc", "sample")), names_to = "covariate", values_to = "covariate_val") %>% 
    group_by(pc, covariate) %>% 
    nest() %>% 
    
    # correlate all pairwise combinations of PCs and covariates
    mutate(pearsons_r = map(.x = data, .f = ~ cor.test(.x$pc_val, .x$covariate_val)$estimate),
           p_val = map(.x = data, .f = ~ cor.test(.x$pc_val, .x$covariate_val)$p.value)) %>% 
    unnest(cols = c(pearsons_r, p_val)) %>% 
    ungroup %>% 
    mutate(p_adj = p.adjust(p_val, method = "fdr")) %>% 
    
    # format df aesthetics
    mutate(covariate = str_replace(covariate, "q_sv", "qSV"),
           covariate = factor(covariate, levels = c(covariate_order, paste0("qSV", 1:16))),
           pc = str_remove(pc, "pc")) %>% 
    left_join(df_var3 %>% mutate(pc = as.character(pc))) %>% 
    dplyr::filter(proportion_of_variance > 0.02) %>% 
    mutate(significant = ifelse(p_adj < 0.05, "yes", "no"))


## Plot PCA3
p_pca <- df_pca %>% 
  ggplot(aes(x = pc1, y = pc2)) +
  geom_point(aes(fill = q_sv1), shape = 21, size = 2) +
  scale_fill_gradientn(colors = brewer.pal(9, "YlOrRd")) +
  guides(fill = guide_colorbar(title = "qSV1")) +
  
  # add origin lines
  # geom_vline(xintercept = 0, color = "black", lty = 2) +
  # geom_hline(yintercept = 0, color = "black", lty = 2) +
  
  # give % variance in axis labels
  xlab(paste0("PC1: ", 
              df_var %>% filter(pc == 1) %>% pull(proportion_of_variance) *100 %>% round(2),
              "% of variance")) +
  ylab(paste0("PC2: ", 
              df_var %>% filter(pc == 2) %>% pull(proportion_of_variance) *100 %>% round(2),
              "% of variance")) +
  theme(legend.position = c(0.10, 0.75))


## Plot eigenvalues
p_var <- df_var %>% 
  ggplot(aes(x = pc, y = proportion_of_variance)) +
  geom_bar(aes(fill = proportion_of_variance), stat = "identity",
           color = "black", linewidth = 0.05) +
  geom_hline(aes(yintercept = 0.02), lty = 2, color = "red") +
  scale_fill_gradient(low = "white", high = "midnightblue", 
                      limits = c(0, 0.07), guide = "none") +
  labs(x = "PC", y = "Proportion of variance explained")

p_pca / p_var + plot_annotation(title = "PCA 3: VST normalized counts with qSV + sex at birth + race + GC percent + age at death regression")


## Save
# map(
#   .x = c(".png", ".pdf"),
#   .f = ~ ggsave(paste0(base_dir, "outputs/figures/for_manuscript/qSVA/PCA3_GENES_normalized_and_regressed_counts", .x),
#                 width = 6, height = 8)
# )
```

## Save objects

```{r save}
## Save PCAs for plotting
save(
    df_pca1_covar_cor, df_pca3_covar_cor,
    file = paste0(analysis_objects_dir, "PCA_regression_res.RData")
)

## Save normalized & regressed gene counts
prefix <- "08Mar2024_GENES_qSVAgeSexRaceGC"
save(df_vsd_regress, file = paste0(base_dir, "objects/", prefix, ".RDS"))
```
